# 04_開発スケジュール.md

---

⚠️ **重要: スキーマ情報について**

このファイルに記載されているデータベーススキーマ（4テーブル構成）は**初期設計版**です。

**現在の正式なスキーマは以下を参照してください:**
- `/revenue-intelligence-platform/database/schema-design-final.md` (16テーブル正規化版)

このファイルのスキーマ情報は参考資料としてのみご利用ください。

---

## 2025年10月 4日間実装スケジュール（96時間）

### 全体タイムライン

```
2025年10月28日（月）〜2025年10月31日（木）
総作業時間: 96時間（1日24時間×4日間）
実作業時間: 80時間（1日20時間×4日間、休憩・食事4時間/日）
```

---

## Day 1（10月28日・月曜日）: 基盤構築 + モックデータ生成

### 【0:00-6:00】環境構築 + プロジェクトセットアップ（6時間）

#### 0:00-2:00: Next.js + Supabase セットアップ
```bash
# プロジェクト作成
npx create-next-app@latest revenue-intelligence-platform \
  --typescript --tailwind --app --use-npm

# 依存関係インストール
npm install @supabase/supabase-js @tanstack/react-query
npm install recharts date-fns zod
npm install -D @types/node

# Supabase CLI セットアップ
npx supabase init
npx supabase start
```

**チェックポイント**:
- [ ] Next.js 14 (App Router) 起動確認
- [ ] Supabase ローカル環境起動確認
- [ ] `.env.local` 設定完了

#### 2:00-4:00: FastAPI マイクロサービス セットアップ
```bash
# FastAPIプロジェクト作成
mkdir fastapi-service && cd fastapi-service
python -m venv venv
source venv/bin/activate

# 依存関係インストール
pip install fastapi uvicorn python-dotenv
pip install google-generativeai redis
pip install pydantic sqlalchemy
```

**ディレクトリ構造作成**:
```
fastapi-service/
├── app/
│   ├── main.py
│   ├── routers/
│   │   ├── revenue_intelligence.py
│   │   ├── suggestions.py
│   │   ├── agents.py
│   │   └── workflow.py
│   ├── services/
│   │   ├── gemini_service.py
│   │   ├── cache_service.py
│   │   └── agent_service.py
│   └── models/
│       └── schemas.py
└── requirements.txt
```

**チェックポイント**:
- [ ] FastAPI サーバー起動確認（`http://localhost:8000/docs`）
- [ ] Gemini API 接続確認
- [ ] Redis ローカル接続確認

#### 4:00-6:00: データベーススキーマ作成
```sql
-- Supabase Migration: companies table
CREATE TABLE companies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  industry TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- deals table
CREATE TABLE deals (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  company_id UUID REFERENCES companies(id),
  salesperson_name TEXT NOT NULL,
  deal_name TEXT NOT NULL,
  stage TEXT NOT NULL,
  amount DECIMAL NOT NULL,
  close_date DATE,
  created_at TIMESTAMP DEFAULT NOW()
);

-- meetings table
CREATE TABLE meetings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  deal_id UUID REFERENCES deals(id),
  meeting_date TIMESTAMP NOT NULL,
  transcript TEXT,
  attendees JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- emails table
CREATE TABLE emails (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  deal_id UUID REFERENCES deals(id),
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  sent_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

**チェックポイント**:
- [ ] 全テーブル作成完了
- [ ] リレーション確認完了
- [ ] インデックス作成完了

---

### 【6:00-14:00】モックデータ生成（8時間）

#### 6:00-8:00: データ生成スクリプト作成
```typescript
// scripts/generateMockData.ts
import { faker } from '@faker-js/faker/locale/ja';
import { createClient } from '@supabase/supabase-js';

// 6社分のベース情報
const companies = [
  { name: 'クラウドテック', industry: 'SaaS', salespeople: 10, deals: 30 },
  { name: 'ビジネスソリューションズ', industry: 'SaaS', salespeople: 12, deals: 40 },
  { name: 'レント東京', industry: '不動産賃貸', salespeople: 10, deals: 35 },
  { name: 'ハウジングパートナーズ', industry: '不動産賃貸', salespeople: 15, deals: 50 },
  { name: 'キャリアブリッジ', industry: '人材紹介', salespeople: 10, deals: 30 },
  { name: 'エグゼクティブサーチ', industry: '人材紹介', salespeople: 8, deals: 25 }
];

// ステージ分布（リアルな確率）
const stageDistribution = {
  'Initial Contact': 0.30,
  'Qualification': 0.25,
  'Proposal': 0.20,
  'Negotiation': 0.15,
  'Closed Won': 0.07,
  'Closed Lost': 0.03
};
```

**チェックポイント**:
- [ ] @faker-js/faker インストール完了
- [ ] 6社分のベース設定完了
- [ ] ステージ分布ロジック実装完了

#### 8:00-11:00: 6社分データ生成実行
- **8:00-8:45**: クラウドテック（SaaS 1社目）
- **8:45-9:30**: ビジネスソリューションズ（SaaS 2社目）
- **9:30-10:15**: レント東京（不動産 1社目）
- **10:15-11:00**: ハウジングパートナーズ（不動産 2社目）

**生成内容（各社共通）**:
```typescript
// 各社ごとに生成
for (const company of companies) {
  // 1. 会社データ挿入
  const companyId = await insertCompany(company);

  // 2. 営業担当者データ生成
  const salespeople = generateSalespeople(company.salespeople);

  // 3. 商談データ生成
  const deals = generateDeals(companyId, salespeople, company.deals);

  // 4. 各商談に対してミーティング生成（1-4回）
  for (const deal of deals) {
    const meetings = generateMeetings(deal, 1-4);
    await insertMeetings(meetings);
  }

  // 5. 各商談に対してメール生成（3-10通）
  for (const deal of deals) {
    const emails = generateEmails(deal, 3-10);
    await insertEmails(emails);
  }
}
```

**チェックポイント**:
- [ ] クラウドテック: 10名営業、30商談、72ミーティング、180メール
- [ ] ビジネスソリューションズ: 12名営業、40商談、96ミーティング、240メール
- [ ] レント東京: 10名営業、35商談、84ミーティング、210メール
- [ ] ハウジングパートナーズ: 15名営業、50商談、120ミーティング、300メール

#### 11:00-14:00: 残り2社 + データ検証
- **11:00-11:45**: キャリアブリッジ（人材 1社目）
- **11:45-12:30**: エグゼクティブサーチ（人材 2社目）
- **12:30-14:00**: データ整合性確認 + 修正

**最終確認クエリ**:
```sql
-- 会社数確認
SELECT COUNT(*) FROM companies; -- 6

-- 営業担当者数確認
SELECT company_id, COUNT(DISTINCT salesperson_name)
FROM deals GROUP BY company_id;

-- 商談数確認
SELECT COUNT(*) FROM deals; -- 210

-- ミーティング数確認
SELECT COUNT(*) FROM meetings; -- 239

-- メール数確認
SELECT COUNT(*) FROM emails; -- 545
```

**チェックポイント**:
- [ ] 全6社データ挿入完了
- [ ] 合計: 65営業、210商談、239ミーティング、545メール
- [ ] データ整合性確認完了（外部キー、NULL値チェック）

---

### 【14:00-20:00】Revenue Intelligence 基本実装（6時間）

#### 14:00-16:00: Gemini Service 実装
```python
# fastapi-service/app/services/gemini_service.py
import google.generativeai as genai
from app.services.cache_service import CacheService

class GeminiService:
    def __init__(self):
        genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
        self.model = genai.GenerativeModel("gemini-2.0-flash-exp")
        self.cache = CacheService()

    async def analyze_deal_risk(self, deal_data: dict) -> dict:
        """Deal Risk Score 計算（キャッシュ戦略適用）"""
        cache_key = f"deal_risk_{deal_data['id']}"

        # キャッシュ確認
        cached = await self.cache.get(cache_key)
        if cached:
            return cached

        # Gemini API呼び出し
        prompt = f"""
        以下の商談データからリスクスコアを0-100で算出してください。

        商談データ:
        - 商談名: {deal_data['name']}
        - ステージ: {deal_data['stage']}
        - 金額: {deal_data['amount']}
        - 最終更新: {deal_data['last_updated']}
        - 直近ミーティング: {deal_data['last_meeting_transcript']}

        JSON形式で返してください:
        {{"risk_score": 0-100, "risk_factors": ["要因1", "要因2"]}}
        """

        response = await self.model.generate_content_async(prompt)
        result = json.loads(response.text)

        # キャッシュ保存（7日間）
        await self.cache.set(cache_key, result, ttl=604800)
        return result
```

**チェックポイント**:
- [ ] GeminiService クラス実装完了
- [ ] キャッシュ統合完了
- [ ] エラーハンドリング実装完了

#### 16:00-18:00: Revenue Intelligence API 実装
```python
# fastapi-service/app/routers/revenue_intelligence.py
from fastapi import APIRouter, HTTPException
from app.services.gemini_service import GeminiService

router = APIRouter(prefix="/api/v1/revenue-intelligence", tags=["RI"])

@router.post("/")
async def calculate_revenue_intelligence(request: RIRequest):
    """Revenue Intelligence 10機能を一括計算"""
    gemini = GeminiService()

    try:
        results = {
            "deal_risk_scores": [],
            "win_rate_analysis": {},
            "buyer_engagement_scores": [],
            "stakeholder_mapping": [],
            "champion_identification": [],
            "win_loss_analysis": {},
            "competitive_intelligence": [],
            "pipeline_velocity": {},
            "next_best_actions": [],
            "revenue_forecasting": {}
        }

        # 1. Deal Risk Score（全商談に対して）
        for deal in request.deals:
            risk = await gemini.analyze_deal_risk(deal.dict())
            results["deal_risk_scores"].append(risk)

        # 2. Win Rate Analysis（バッチ処理）
        results["win_rate_analysis"] = await gemini.analyze_win_rate(
            request.deals
        )

        # 3-10. 残りの機能を実装...

        return {"results": results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

**実装する10機能**:
1. Deal Risk Score
2. Win Rate Analysis
3. Buyer Engagement Scoring
4. Stakeholder Mapping
5. Champion Identification
6. Win-Loss Analysis
7. Competitive Intelligence
8. Pipeline Velocity
9. Next Best Action
10. Revenue Forecasting

**チェックポイント**:
- [ ] 10機能全てのエンドポイント実装完了
- [ ] バッチ処理実装完了（1リクエストで複数商談処理）
- [ ] エラーハンドリング実装完了

#### 18:00-20:00: Next.js API Routes 実装
```typescript
// app/api/companies/route.ts
import { createClient } from '@supabase/supabase-js';

export async function GET(request: Request) {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  const { data, error } = await supabase
    .from('companies')
    .select('*');

  if (error) {
    return Response.json({ error: error.message }, { status: 500 });
  }

  return Response.json({ companies: data });
}

// app/api/deals/route.ts（同様に実装）
// app/api/meetings/route.ts（同様に実装）
```

**チェックポイント**:
- [ ] `/api/companies` 実装完了
- [ ] `/api/deals` 実装完了（フィルタリング対応）
- [ ] `/api/meetings` 実装完了
- [ ] `/api/cache` 実装完了

---

### 【20:00-24:00】Day 1 総合テスト（4時間）

#### 20:00-22:00: API統合テスト
```bash
# Next.js API Routes テスト
curl http://localhost:3000/api/companies
curl http://localhost:3000/api/deals?company_id=xxx

# FastAPI テスト
curl -X POST http://localhost:8000/api/v1/revenue-intelligence \
  -H "Content-Type: application/json" \
  -d @test_payload.json
```

**チェックポイント**:
- [ ] 全APIエンドポイント正常動作確認
- [ ] Gemini API呼び出し成功確認
- [ ] キャッシュ動作確認

#### 22:00-24:00: データ確認 + Day 1 まとめ
- モックデータの品質確認
- Gemini API使用量確認（アラート: 1,200 requests/day）
- 翌日の準備

**Day 1 完了チェックリスト**:
- [ ] Next.js + FastAPI 環境構築完了
- [ ] Supabase + Redis セットアップ完了
- [ ] 6社分モックデータ生成完了（210商談、239ミーティング、545メール）
- [ ] Revenue Intelligence 10機能実装完了
- [ ] 全APIエンドポイント動作確認完了

---

## Day 2（10月29日・火曜日）: AI Agents実装

### 【0:00-8:00】Suggestion Engine 実装（8時間）

#### 0:00-3:00: Next Best Action 実装
```python
# fastapi-service/app/routers/suggestions.py
@router.post("/next-action")
async def suggest_next_action(request: NextActionRequest):
    """Next Best Action 提案"""
    gemini = GeminiService()

    prompt = f"""
    以下の商談情報から、営業担当者が次に取るべきアクションを3つ提案してください。

    商談情報:
    - ステージ: {request.stage}
    - リスクスコア: {request.risk_score}
    - 最終接触: {request.last_contact_days}日前
    - 直近ミーティング要約: {request.last_meeting_summary}

    JSON形式:
    {{
      "actions": [
        {{"action": "アクション1", "priority": "high", "rationale": "理由"}},
        {{"action": "アクション2", "priority": "medium", "rationale": "理由"}},
        {{"action": "アクション3", "priority": "low", "rationale": "理由"}}
      ]
    }}
    """

    response = await gemini.model.generate_content_async(prompt)
    return json.loads(response.text)
```

**チェックポイント**:
- [ ] Next Best Action API実装完了
- [ ] 優先度ロジック実装完了
- [ ] テストケース3パターン実行完了

#### 3:00-6:00: Risk Detection 実装
```python
@router.post("/risk-detection")
async def detect_risks(request: RiskDetectionRequest):
    """リスク検出 + アラート"""
    gemini = GeminiService()

    # 高リスク商談を抽出
    high_risk_deals = [d for d in request.deals if d.risk_score > 70]

    if not high_risk_deals:
        return {"alerts": []}

    # Geminiでリスク要因分析（バッチ処理）
    prompt = f"""
    以下の{len(high_risk_deals)}件の高リスク商談について、リスク要因を分析してください。

    商談リスト:
    {json.dumps([d.dict() for d in high_risk_deals], ensure_ascii=False)}

    各商談について:
    - top_risk_factors: リスク要因トップ3
    - recommended_actions: 推奨アクション
    - urgency_level: 緊急度（high/medium/low）
    """

    response = await gemini.model.generate_content_async(prompt)
    return json.loads(response.text)
```

**チェックポイント**:
- [ ] Risk Detection API実装完了
- [ ] アラートロジック実装完了
- [ ] バッチ処理動作確認

#### 6:00-8:00: Proposal Draft 生成実装
```python
@router.post("/proposal")
async def generate_proposal(request: ProposalRequest):
    """提案書ドラフト生成"""
    gemini = GeminiService()

    prompt = f"""
    以下の情報から提案書のドラフトを日本語で生成してください。

    顧客情報:
    - 会社名: {request.company_name}
    - 業界: {request.industry}
    - 課題: {request.pain_points}

    過去の商談履歴:
    {request.meeting_summaries}

    提案書構成:
    1. エグゼクティブサマリー
    2. 課題分析
    3. ソリューション提案
    4. 期待効果
    5. 料金プラン
    6. 導入スケジュール

    各セクション200-300文字で作成してください。
    """

    response = await gemini.model.generate_content_async(prompt)
    return {"proposal_draft": response.text}
```

**チェックポイント**:
- [ ] Proposal Generation API実装完了
- [ ] 提案書フォーマット確認
- [ ] 3業界（SaaS/不動産/人材）でテスト完了

---

### 【8:00-16:00】CrewAI Multi-Agent 実装（8時間）

#### 8:00-10:00: CrewAI セットアップ + Email Worker
```python
# fastapi-service/app/services/agent_service.py
from crewai import Agent, Task, Crew

class EmailWorker:
    def __init__(self):
        self.agent = Agent(
            role="Email Specialist",
            goal="顧客へのフォローメールを生成する",
            backstory="営業支援のメール作成エキスパート",
            llm="gemini-2.0-flash-exp"
        )

    async def generate_followup_email(self, context: dict) -> str:
        task = Task(
            description=f"""
            以下の商談情報から、顧客へのフォローメールを作成してください。

            商談名: {context['deal_name']}
            最終ミーティング: {context['last_meeting_summary']}
            次のアクション: {context['next_action']}

            メールは丁寧かつ簡潔に、250文字以内で作成してください。
            """,
            agent=self.agent
        )

        crew = Crew(agents=[self.agent], tasks=[task])
        result = await crew.kickoff_async()
        return result
```

**チェックポイント**:
- [ ] CrewAI インストール完了
- [ ] Email Worker 実装完了
- [ ] テストメール3パターン生成確認

#### 10:00-12:00: Document Worker 実装
```python
class DocumentWorker:
    def __init__(self):
        self.agent = Agent(
            role="Document Analyst",
            goal="ミーティング議事録や提案書を分析する",
            backstory="ドキュメント分析のスペシャリスト",
            llm="gemini-2.0-flash-exp"
        )

    async def summarize_meeting(self, transcript: str) -> dict:
        task = Task(
            description=f"""
            以下のミーティング文字起こしを分析してください。

            文字起こし:
            {transcript}

            以下の形式で返してください:
            - summary: 要約（100文字以内）
            - key_points: 重要ポイント3つ
            - action_items: アクションアイテム
            - sentiment: 顧客の感情（positive/neutral/negative）
            """,
            agent=self.agent
        )

        crew = Crew(agents=[self.agent], tasks=[task])
        result = await crew.kickoff_async()
        return result
```

**チェックポイント**:
- [ ] Document Worker 実装完了
- [ ] ミーティング要約テスト3件完了
- [ ] センチメント分析精度確認

#### 12:00-14:00: CRM Worker 実装
```python
class CRMWorker:
    def __init__(self):
        self.agent = Agent(
            role="CRM Data Specialist",
            goal="CRMデータを更新・最適化する",
            backstory="CRM運用のエキスパート",
            llm="gemini-2.0-flash-exp"
        )

    async def suggest_crm_updates(self, deal_data: dict) -> dict:
        task = Task(
            description=f"""
            以下の商談データから、CRMに更新すべき情報を提案してください。

            現在のCRMデータ:
            {json.dumps(deal_data, ensure_ascii=False)}

            提案内容:
            - field_updates: 更新すべきフィールドと値
            - missing_info: 不足している情報
            - data_quality_score: データ品質スコア（0-100）
            """,
            agent=self.agent
        )

        crew = Crew(agents=[self.agent], tasks=[task])
        result = await crew.kickoff_async()
        return result
```

**チェックポイント**:
- [ ] CRM Worker 実装完了
- [ ] データ品質スコアリング確認
- [ ] 更新提案の妥当性確認

#### 14:00-16:00: Multi-Agent Collaboration 実装
```python
class MultiAgentOrchestrator:
    def __init__(self):
        self.email_worker = EmailWorker()
        self.document_worker = DocumentWorker()
        self.crm_worker = CRMWorker()

    async def process_deal_workflow(self, deal_id: str) -> dict:
        """3つのAgentを協調させて商談処理"""

        # 1. Document Worker: ミーティング分析
        meeting_analysis = await self.document_worker.summarize_meeting(
            deal_data['last_meeting_transcript']
        )

        # 2. CRM Worker: CRM更新提案
        crm_updates = await self.crm_worker.suggest_crm_updates(deal_data)

        # 3. Email Worker: フォローメール生成
        followup_email = await self.email_worker.generate_followup_email({
            'deal_name': deal_data['name'],
            'last_meeting_summary': meeting_analysis['summary'],
            'next_action': meeting_analysis['action_items'][0]
        })

        return {
            "meeting_analysis": meeting_analysis,
            "crm_updates": crm_updates,
            "followup_email": followup_email
        }
```

**チェックポイント**:
- [ ] Multi-Agent Orchestrator 実装完了
- [ ] 3つのWorkerの連携動作確認
- [ ] エンドツーエンドテスト完了

---

### 【16:00-24:00】LangGraph 実装 + Day 2テスト（8時間）

#### 16:00-19:00: LangGraph State Machine 実装
```python
# fastapi-service/app/services/workflow_service.py
from langgraph.graph import StateGraph, END

class DealWorkflowState(TypedDict):
    deal_id: str
    stage: str
    risk_score: int
    next_actions: List[str]
    email_sent: bool
    crm_updated: bool

class LangGraphWorkflow:
    def __init__(self):
        self.workflow = StateGraph(DealWorkflowState)
        self._build_graph()

    def _build_graph(self):
        # ノード定義
        self.workflow.add_node("assess_risk", self._assess_risk)
        self.workflow.add_node("generate_actions", self._generate_actions)
        self.workflow.add_node("send_email", self._send_email)
        self.workflow.add_node("update_crm", self._update_crm)

        # エッジ定義（条件分岐）
        self.workflow.set_entry_point("assess_risk")
        self.workflow.add_edge("assess_risk", "generate_actions")

        # 条件分岐: リスクスコアが70以上ならメール送信
        self.workflow.add_conditional_edges(
            "generate_actions",
            self._should_send_email,
            {
                "send_email": "send_email",
                "update_crm": "update_crm"
            }
        )

        self.workflow.add_edge("send_email", "update_crm")
        self.workflow.add_edge("update_crm", END)

    async def _assess_risk(self, state: DealWorkflowState) -> DealWorkflowState:
        # Gemini APIでリスク評価
        gemini = GeminiService()
        risk = await gemini.analyze_deal_risk({"id": state["deal_id"]})
        state["risk_score"] = risk["risk_score"]
        return state

    def _should_send_email(self, state: DealWorkflowState) -> str:
        return "send_email" if state["risk_score"] >= 70 else "update_crm"

    async def execute(self, initial_state: DealWorkflowState) -> DealWorkflowState:
        app = self.workflow.compile()
        final_state = await app.ainvoke(initial_state)
        return final_state
```

**チェックポイント**:
- [ ] LangGraph StateGraph 実装完了
- [ ] 条件分岐ロジック動作確認
- [ ] 3パターンのワークフロー実行確認

#### 19:00-21:00: LangGraph API エンドポイント実装
```python
# fastapi-service/app/routers/workflow.py
@router.post("/execute")
async def execute_workflow(request: WorkflowRequest):
    """LangGraph ワークフロー実行"""
    workflow = LangGraphWorkflow()

    initial_state = DealWorkflowState(
        deal_id=request.deal_id,
        stage=request.stage,
        risk_score=0,
        next_actions=[],
        email_sent=False,
        crm_updated=False
    )

    final_state = await workflow.execute(initial_state)

    return {
        "workflow_result": final_state,
        "execution_time": "2.3s"
    }
```

**チェックポイント**:
- [ ] `/api/v1/workflow/execute` 実装完了
- [ ] ワークフロー実行ログ記録実装
- [ ] エラーハンドリング実装

#### 21:00-24:00: Day 2 総合テスト
- Suggestion Engine 3機能テスト
- CrewAI 3 Workers テスト
- LangGraph ワークフロー実行テスト
- Gemini API使用量確認（アラート: 1,200 requests/day）

**Day 2 完了チェックリスト**:
- [ ] Suggestion Engine 3機能実装完了
- [ ] CrewAI Multi-Agent 3 Workers実装完了
- [ ] LangGraph State Machine実装完了
- [ ] 全AI Agents API動作確認完了

---

## Day 3（10月30日・水曜日）: UI実装 + 統合

### 【0:00-10:00】フロントエンド UI実装（10時間）

#### 0:00-3:00: ダッシュボード画面実装
```typescript
// app/dashboard/page.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { BarChart, LineChart } from 'recharts';

export default function DashboardPage() {
  const { data: companies } = useQuery({
    queryKey: ['companies'],
    queryFn: () => fetch('/api/companies').then(r => r.json())
  });

  const { data: riResults } = useQuery({
    queryKey: ['revenue-intelligence'],
    queryFn: () => fetch('http://localhost:8000/api/v1/revenue-intelligence', {
      method: 'POST',
      body: JSON.stringify({ company_id: companies[0].id })
    }).then(r => r.json())
  });

  return (
    <div className="grid grid-cols-3 gap-4">
      {/* Revenue Forecasting Card */}
      <Card>
        <h2>Revenue Forecasting</h2>
        <LineChart data={riResults?.revenue_forecasting} />
      </Card>

      {/* Deal Risk Scores */}
      <Card>
        <h2>High Risk Deals</h2>
        <ul>
          {riResults?.deal_risk_scores
            .filter(d => d.risk_score > 70)
            .map(deal => (
              <li key={deal.id}>{deal.name}: {deal.risk_score}</li>
            ))}
        </ul>
      </Card>

      {/* Win Rate Analysis */}
      <Card>
        <h2>Win Rate by Stage</h2>
        <BarChart data={riResults?.win_rate_analysis} />
      </Card>
    </div>
  );
}
```

**チェックポイント**:
- [ ] ダッシュボードレイアウト実装完了
- [ ] React Query統合完了
- [ ] Recharts グラフ表示確認

#### 3:00-6:00: 商談詳細画面実装
```typescript
// app/deals/[id]/page.tsx
export default function DealDetailPage({ params }: { params: { id: string } }) {
  const { data: deal } = useQuery({
    queryKey: ['deal', params.id],
    queryFn: () => fetch(`/api/deals/${params.id}`).then(r => r.json())
  });

  const { data: suggestions } = useQuery({
    queryKey: ['suggestions', params.id],
    queryFn: () => fetch('http://localhost:8000/api/v1/suggestions/next-action', {
      method: 'POST',
      body: JSON.stringify({ deal_id: params.id })
    }).then(r => r.json())
  });

  return (
    <div>
      {/* 商談基本情報 */}
      <section>
        <h1>{deal?.name}</h1>
        <p>ステージ: {deal?.stage}</p>
        <p>金額: ¥{deal?.amount?.toLocaleString()}</p>
      </section>

      {/* AI Suggestions */}
      <section>
        <h2>Next Best Actions</h2>
        {suggestions?.actions.map(action => (
          <ActionCard key={action.action} {...action} />
        ))}
      </section>

      {/* ミーティング履歴 */}
      <section>
        <h2>Meeting History</h2>
        <MeetingList dealId={params.id} />
      </section>
    </div>
  );
}
```

**チェックポイント**:
- [ ] 商談詳細画面実装完了
- [ ] Next Best Actions 表示確認
- [ ] ミーティング履歴表示確認

#### 6:00-8:00: AI Agents 実行画面実装
```typescript
// app/agents/page.tsx
export default function AgentsPage() {
  const [workflowResult, setWorkflowResult] = useState(null);

  const executeWorkflow = async (dealId: string) => {
    const response = await fetch('http://localhost:8000/api/v1/workflow/execute', {
      method: 'POST',
      body: JSON.stringify({ deal_id: dealId, stage: 'Proposal' })
    });

    const result = await response.json();
    setWorkflowResult(result);
  };

  return (
    <div>
      <h1>AI Agents Workflow</h1>

      {/* CrewAI Workers Status */}
      <div className="grid grid-cols-3 gap-4">
        <WorkerCard name="Email Worker" status="ready" />
        <WorkerCard name="Document Worker" status="ready" />
        <WorkerCard name="CRM Worker" status="ready" />
      </div>

      {/* LangGraph Execution */}
      <button onClick={() => executeWorkflow('deal-123')}>
        Execute Workflow
      </button>

      {workflowResult && (
        <WorkflowResultDisplay result={workflowResult} />
      )}
    </div>
  );
}
```

**チェックポイント**:
- [ ] AI Agents画面実装完了
- [ ] ワークフロー実行ボタン動作確認
- [ ] 結果表示確認

#### 8:00-10:00: レスポンシブデザイン + Tailwind CSS調整
- モバイル対応
- ダークモード対応
- アクセシビリティ対応

**チェックポイント**:
- [ ] モバイル表示確認（375px, 768px, 1024px）
- [ ] ダークモード切り替え動作確認
- [ ] キーボードナビゲーション確認

---

### 【10:00-18:00】エンドツーエンド統合（8時間）

#### 10:00-13:00: Next.js ⇄ FastAPI 統合
```typescript
// lib/api-client.ts
export class APIClient {
  private nextApiBase = process.env.NEXT_PUBLIC_API_URL;
  private fastApiBase = process.env.NEXT_PUBLIC_FASTAPI_URL;

  // Next.js API Routes
  async getCompanies() {
    return fetch(`${this.nextApiBase}/companies`).then(r => r.json());
  }

  async getDeals(companyId: string) {
    return fetch(`${this.nextApiBase}/deals?company_id=${companyId}`)
      .then(r => r.json());
  }

  // FastAPI Microservice
  async calculateRI(payload: RIRequest) {
    return fetch(`${this.fastApiBase}/api/v1/revenue-intelligence`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).then(r => r.json());
  }

  async executeWorkflow(dealId: string) {
    return fetch(`${this.fastApiBase}/api/v1/workflow/execute`, {
      method: 'POST',
      body: JSON.stringify({ deal_id: dealId })
    }).then(r => r.json());
  }
}
```

**チェックポイント**:
- [ ] APIClient クラス実装完了
- [ ] CORS設定確認
- [ ] エラーハンドリング実装

#### 13:00-15:00: キャッシュ戦略統合テスト
```python
# Redis キャッシュ動作確認
async def test_cache_strategy():
    # 1回目: Gemini API呼び出し（キャッシュなし）
    result1 = await gemini.analyze_deal_risk(deal_data)
    assert redis.get(f"deal_risk_{deal_id}") is not None

    # 2回目: キャッシュヒット（Gemini API呼び出しなし）
    result2 = await gemini.analyze_deal_risk(deal_data)
    assert result1 == result2

    # Gemini API使用量確認
    # キャッシュヒット時はAPI呼び出しなし
```

**キャッシュ戦略確認項目**:
- [ ] Redis接続確認
- [ ] キャッシュヒット率確認（目標: 50%）
- [ ] TTL設定確認（7日間）

#### 15:00-18:00: パフォーマンステスト
```bash
# Apache Bench でロードテスト
ab -n 100 -c 10 http://localhost:3000/api/companies

# FastAPI エンドポイント負荷テスト
ab -n 50 -c 5 -p test_payload.json \
  http://localhost:8000/api/v1/revenue-intelligence
```

**パフォーマンス目標**:
- [ ] Next.js API: 平均レスポンス < 100ms
- [ ] FastAPI: 平均レスポンス < 2000ms（Gemini API含む）
- [ ] フロントエンド初期ロード < 3秒

---

### 【18:00-24:00】Day 3 総合テスト（6時間）

#### 18:00-21:00: 6社分データでのフルテスト
```typescript
// E2Eテストシナリオ
describe('Revenue Intelligence Platform E2E', () => {
  test('クラウドテック（SaaS）のダッシュボード表示', async () => {
    // 1. 会社選択
    await page.goto('/dashboard');
    await page.click('[data-company="クラウドテック"]');

    // 2. Revenue Intelligence計算
    await page.waitForSelector('[data-testid="ri-results"]');

    // 3. グラフ表示確認
    expect(await page.$$('[data-chart="revenue-forecast"]')).toHaveLength(1);
  });

  test('商談詳細 → AI Agents実行', async () => {
    // 1. 高リスク商談を選択
    await page.click('[data-risk-level="high"]');

    // 2. Next Best Actions確認
    expect(await page.$$('[data-testid="action-card"]')).toHaveLength(3);

    // 3. ワークフロー実行
    await page.click('[data-action="execute-workflow"]');
    await page.waitForSelector('[data-testid="workflow-result"]');
  });
});
```

**テストケース**:
- [ ] 6社すべてでダッシュボード表示確認
- [ ] 高リスク商談（15件）で AI Agents実行確認
- [ ] 提案書生成（3業界各1件）確認

#### 21:00-24:00: Gemini API使用量最終確認
```python
# Gemini API使用量確認
total_requests = await redis.get("gemini_request_count_day3")

print(f"Day 1-3累計リクエスト: {total_requests}")
print(f"無料枠使用率: {total_requests / 1500 * 100:.2f}%")

# アラート設定: 1,200 requests/day（80%）
if total_requests >= 1200:
    logger.warning("Gemini API: 1,200 requests/day reached (80% of free tier)")
```

**最終確認項目**:
- [ ] Gemini API使用量確認（アラート: 1,200 requests/day）
- [ ] キャッシュヒット率確認（必要に応じて）
- [ ] 全機能動作確認完了

**Day 3 完了チェックリスト**:
- [ ] フロントエンドUI全画面実装完了
- [ ] Next.js ⇄ FastAPI統合完了
- [ ] キャッシュ戦略動作確認
- [ ] E2Eテスト全パス

---

## Day 4（10月31日・木曜日）: 本番API統合 + デプロイ

### 【0:00-4:00】Phase 0: 本番Gemini API統合テスト（4時間）← **新規追加**

**重要**: Day 1-3は全てモックモードで開発し、Day 4の最初に本番API統合テストを実施します。

#### 0:00-0:30: Phase 0-1: モックモード解除 + 基本動作確認
```bash
# 1. 環境変数編集
cd fastapi-service
nano .env

# 変更内容:
USE_MOCK_GEMINI=false  # true → false に変更
USE_MOCK_CREWAI=false  # true → false に変更
GEMINI_API_KEY=YOUR_GEMINI_API_KEY_HERE

# 2. FastAPI再起動
source venv/bin/activate
uvicorn app.main:app --reload

# 3. 基本接続テスト
curl http://localhost:8000/health
curl http://localhost:8000/test-gemini
```

**チェックリスト**:
- [ ] FastAPI正常起動確認
- [ ] `/test-gemini` エンドポイントで実際のGemini API接続成功
- [ ] エラーログ確認（Python警告なし）

#### 0:30-2:00: Phase 0-2: Revenue Intelligence 10機能テスト（90分）
各機能を2回ずつテスト（合計20リクエスト）:
1. 商談リスク分析（analyze-deal-risk）
2. 成約率分析（analyze-win-rate）
3. 次のアクション提案（generate-next-actions）
4. 売上予測（forecast-revenue）
5. チャーンリスク予測（predict-churn-risk）
6. アップセル機会検知（detect-upsell-opportunities）
7. 競合分析（analyze-competitors）
8. 営業パフォーマンス分析（analyze-sales-performance）
9. ミーティング要約（summarize-meetings）
10. 商談進捗トラッキング（track-deal-progress）

**チェックリスト（各機能共通）**:
- [ ] レスポンス成功（200 OK）
- [ ] JSON形式で返却
- [ ] モックレスポンスと構造が一致
- [ ] レスポンス時間 < 3000ms
- [ ] 日本語レスポンス品質確認

#### 2:00-2:30: Phase 0-3: Suggestion Engine 3機能テスト（30分）
各機能を2回ずつテスト（合計6リクエスト）:
1. Next Best Action提案（suggest-next-best-action）
2. Risk Detection（detect-risk-alerts）
3. Proposal Generation（generate-proposal-draft）

**チェックリスト**:
- [ ] 全3機能テスト完了（各2回）
- [ ] レスポンス品質確認（日本語、文章の自然さ）
- [ ] エラーハンドリング動作確認

#### 2:30-3:00: Phase 0-4: CrewAI 3 Workers テスト（30分）
各Workerテスト（合計8リクエスト）:
1. Email Worker（generate-followup-email）
2. Document Worker（summarize-meeting）
3. CRM Worker（suggest-crm-updates）
4. Multi-Agent Workflow（統合テスト）

**チェックリスト**:
- [ ] Email Worker: 日本語メール品質確認
- [ ] Document Worker: 要約精度確認
- [ ] CRM Worker: データ品質スコア妥当性確認
- [ ] Multi-Agent Workflow: 3つのWorker協調動作確認

#### 3:00-3:30: Phase 0-5: LangGraph Workflow テスト（30分）
LangGraph State Machine実行（合計4リクエスト）:
- 3パターンのワークフロー実行確認
- 条件分岐ロジック動作確認（risk_score ≥ 70）

**チェックリスト**:
- [ ] LangGraph StateGraph動作確認
- [ ] 条件分岐ロジック動作確認
- [ ] 3パターンのワークフロー実行確認

#### 3:30-4:00: Phase 0-6: API使用量確認 + エラーハンドリング強化（30分）
```python
# API使用量集計エンドポイント実装
@app.get("/api/gemini-usage")
async def get_gemini_usage():
    return {
        "total_requests": gemini_request_count,
        "free_tier_limit": 1500,
        "usage_percentage": (gemini_request_count / 1500) * 100,
        "remaining_requests": 1500 - gemini_request_count
    }
```

**予想されるAPI使用量**:
```
Day 4 Phase 0 本番API統合テスト:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 0-1: 基本接続テスト: 1 request
Phase 0-2: Revenue Intelligence: 20 requests
Phase 0-3: Suggestion Engine: 6 requests
Phase 0-4: CrewAI Workers: 8 requests
Phase 0-5: LangGraph Workflow: 4 requests
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
合計: 39 requests（無料枠の2.6%）✅
```

**チェックリスト**:
- [ ] API使用量集計エンドポイント実装
- [ ] リトライロジック実装（全エンドポイント）
- [ ] タイムアウト設定確認（30秒）
- [ ] エラーログ記録実装

---

### 【4:00-8:00】Phase 1: 最終調整 + ドキュメント作成（4時間）← 時間調整

#### 4:00-6:00: バグ修正 + UI調整
- Day 3で発見したバグ修正
- UIの細かい調整
- エラーメッセージの日本語化

**修正予定項目**:
- [ ] エラーハンドリング改善（10箇所）
- [ ] ローディング状態の改善（5箇所）
- [ ] 日本語文言の調整（20箇所）

#### 6:00-8:00: README.md + API Documentation + デモ準備
```markdown
# Revenue Intelligence Platform - 実装完了版

## 概要
2025年10月完成のRevenue Intelligence Platform プロトタイプ

## 技術スタック
- フロントエンド: Next.js 14 (App Router) + TypeScript + Tailwind CSS
- バックエンド: FastAPI + Python 3.11
- AI/ML: Gemini 2.0 Flash (無料枠) + CrewAI + LangGraph
- データベース: Supabase (PostgreSQL)
- キャッシュ: Redis

## セットアップ手順
1. 環境変数設定
2. 依存関係インストール
3. モックデータ生成
4. サーバー起動

## API仕様
（03_API仕様.mdへのリンク）

## 開発スケジュール
（04_開発スケジュール.mdへのリンク）
```

**チェックポイント**:
- [ ] README.md作成完了
- [ ] API Documentation作成完了
- [ ] セットアップ手順検証完了
- [ ] デモシナリオ作成完了

**デモシナリオ**:
1. ダッシュボード表示（Revenue Forecasting）
2. 高リスク商談の特定
3. Next Best Actions提案
4. AI Agents（CrewAI）実行
5. LangGraphワークフロー実行

---

### 【8:00-16:00】Phase 2: デプロイ（8時間）

#### 8:00-11:00: Vercel デプロイ（Next.js）
```bash
# Vercel CLI セットアップ
npm i -g vercel

# デプロイ
vercel --prod

# 環境変数設定
vercel env add NEXT_PUBLIC_SUPABASE_URL
vercel env add SUPABASE_SERVICE_ROLE_KEY
vercel env add NEXT_PUBLIC_FASTAPI_URL
```

**チェックポイント**:
- [ ] Vercel デプロイ成功
- [ ] 環境変数設定完了
- [ ] 本番環境動作確認

#### 11:00-14:00: Railway デプロイ（FastAPI）
```bash
# Railway CLI セットアップ
npm i -g @railway/cli

# プロジェクト作成
railway init

# デプロイ
railway up

# 環境変数設定
railway variables set GEMINI_API_KEY=xxx
railway variables set REDIS_URL=xxx
```

**チェックポイント**:
- [ ] Railway デプロイ成功
- [ ] FastAPI起動確認（`https://xxx.railway.app/docs`）
- [ ] Gemini API接続確認

#### 14:00-16:00: Supabase Production セットアップ
```bash
# Supabase プロジェクト作成
npx supabase projects create revenue-intelligence-platform

# マイグレーション実行
npx supabase db push

# モックデータ投入
npm run seed:production
```

**チェックポイント**:
- [ ] Supabase本番環境作成完了
- [ ] スキーマ作成完了
- [ ] モックデータ投入完了（6社分）

---

### 【16:00-24:00】Phase 3: 最終テスト + 完成（8時間）

#### 16:00-19:00: 本番環境E2Eテスト
```typescript
// Playwright E2Eテスト（本番環境）
test('本番環境: クラウドテックのダッシュボード', async ({ page }) => {
  await page.goto('https://revenue-intelligence-platform.vercel.app');

  // 会社選択
  await page.click('[data-company="クラウドテック"]');

  // Revenue Intelligence計算
  await page.waitForResponse(
    response => response.url().includes('/api/v1/revenue-intelligence')
  );

  // 結果表示確認
  expect(await page.textContent('[data-testid="forecast-value"]'))
    .toContain('¥4,500,000');
});
```

**テストケース（本番環境）**:
- [ ] 6社すべてのダッシュボード表示
- [ ] Revenue Intelligence 10機能すべて動作
- [ ] AI Agents（CrewAI + LangGraph）動作
- [ ] Gemini API使用量確認（アラート: 1,200 requests/day）

#### 19:00-21:00: パフォーマンス最終確認
```bash
# Lighthouse CI
npm run lighthouse:ci

# 目標スコア
# Performance: 90+
# Accessibility: 95+
# Best Practices: 90+
# SEO: 90+
```

**チェックポイント**:
- [ ] Lighthouse Performance 90+
- [ ] Core Web Vitals すべてGood
- [ ] モバイル表示確認

#### 21:00-23:00: デモ動画撮影
```markdown
## デモ動画構成（5分間）

0:00-0:30: オープニング + 概要説明
0:30-1:30: ダッシュボード（Revenue Intelligence 10機能）
1:30-2:30: 商談詳細 + Next Best Actions
2:30-3:30: AI Agents（CrewAI Multi-Agent）
3:30-4:30: LangGraph ワークフロー実行
4:30-5:00: まとめ + 技術スタック紹介
```

**チェックポイント**:
- [ ] デモ動画撮影完了（5分）
- [ ] 字幕追加完了
- [ ] YouTube/Vimeoアップロード完了

#### 23:00-24:00: 最終確認 + プロジェクト完成
**最終チェックリスト**:
- [ ] Phase 0完了: 本番Gemini API統合テスト完了（39 requests）✅
- [ ] 全機能動作確認完了（本番API使用）
- [ ] Gemini API使用量: 50 requests未満（無料枠の3.3%）✅
- [ ] モックデータ6社分正常動作
- [ ] デプロイ完了（Vercel + Railway + Supabase）
- [ ] ドキュメント完成（README + API仕様）
- [ ] デモ動画完成

---

## 完成時の成果物

### 1. 稼働中のアプリケーション
- **フロントエンド**: https://revenue-intelligence-platform.vercel.app
- **FastAPI**: https://xxx.railway.app
- **Supabase**: 本番環境稼働中

### 2. 実装済み機能
#### Revenue Intelligence（10機能）
1. ✅ Deal Risk Score
2. ✅ Win Rate Analysis
3. ✅ Buyer Engagement Scoring
4. ✅ Stakeholder Mapping
5. ✅ Champion Identification
6. ✅ Win-Loss Analysis
7. ✅ Competitive Intelligence
8. ✅ Pipeline Velocity
9. ✅ Next Best Action
10. ✅ Revenue Forecasting

#### AI Agents
1. ✅ Suggestion Engine（3機能）
2. ✅ CrewAI Multi-Agent（3 Workers）
3. ✅ LangGraph State Orchestration

### 3. モックデータ
- ✅ 6社（SaaS 2社、不動産 2社、人材 2社）
- ✅ 65名の営業担当者
- ✅ 210件の商談
- ✅ 239件のミーティング
- ✅ 545通のメール

### 4. ドキュメント
- ✅ 00_実装計画.md
- ✅ 01_モックデータ仕様.md
- ✅ 03_API仕様.md
- ✅ 04_開発スケジュール.md（本ファイル）
- ✅ README.md
- ✅ API Documentation

### 5. デモ資料
- ✅ デモ動画（5分）
- ✅ プレゼン資料

---

## Gemini API無料枠使用量（最終確認）

### 4日間の累計リクエスト数（更新版）

| Day | 用途 | リクエスト数 | 累計 | 備考 |
|-----|------|------------|------|------|
| Day 1 | Revenue Intelligence開発 | 0 | 0 | モックモード実装 |
| Day 2 | AI Agents開発 | 0 | 0 | モックモード実装 |
| Day 3 | フロントエンドUI開発 | 0 | 0 | モックAPI連携 |
| **Day 4 Phase 0** | **本番API統合テスト** | **39** | **39** | **初使用** |
| Day 4 Phase 1-3 | 本番環境テスト | 11 | 50 | デプロイ後テスト |
| **合計** | | **50** | **3.3%** | ✅ 無料枠内 |

**無料枠**: 1,500 requests/day
**アラート設定**: 1,200 requests/day（80%）で警告 ✅
**実績**: 50 requests（3.3%）← 十分な余裕

### 開発戦略の変更点

**旧計画**:
- Day 1-4全体で少しずつ本番API使用（合計14 requests）
- キャッシュ戦略で削減率70.8%

**新計画** ← **Option C採用**:
- **Day 1-3**: 全てモックモードで高速開発（0 requests）
- **Day 4 Phase 0**: 本番API統合テスト（39 requests）← 集中テスト
- **Day 4 Phase 1-3**: デプロイ + 本番環境テスト（11 requests）
- **合計**: 50 requests（3.3%）← 旧計画より使用量増加だが、無料枠内で安全

---

## リスク管理

### 開発中に発生しうるリスク

| リスク | 対策 |
|--------|------|
| Gemini API無料枠超過 | キャッシュ戦略徹底、予算アラート設定 |
| FastAPIデプロイ失敗 | Railway以外にRender.comも候補 |
| モックデータ生成に時間がかかる | 並列処理、データ量削減オプション |
| E2Eテスト失敗 | 手動テストで補完、優先度高い機能から |
| デプロイ後の動作不良 | ローカル環境と本番環境の差分確認 |

---

## 次のステップ（プロトタイプ完成後）

### Year 2以降の改善計画
1. **テンプレート化**: 3業界（SaaS/不動産/人材）のテンプレート抽出
2. **実CRM連携**: Salesforce/HubSpot APIとの連携
3. **プロダクション化**: エラー監視、ログ収集、セキュリティ強化
4. **パフォーマンス最適化**: バッチ処理の効率化、N+1問題解消

---

**プロジェクト完成予定日**: 2025年10月31日 24:00 ✅
